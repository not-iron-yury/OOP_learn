Методы __new__() и __init__()

Когда мы вызываем класс, мы запускаем внутренний процесс конструирования экземпляра класса,
который состоит из двух шагов:
1) создание нового пустого экземпляра класса 	# метод __new__()
2) инициализация созданного экземпляра класса	# метод __init__()

Для выполнения первого шага все классы имеют магический метод __new__(), который отвечает за создание
и возврат нового пустого экземпляра класса. Затем созданный экземпляр передается в метод __init__() для инициализации,
то есть для установки его атрибутам необходимых значений.


object.__new__(cls, *args, **kwargs)
Метод вызывается для создания нового экземпляра класса cls.__new__() - это статический метод,
который принимает в качестве аргумента класс cls.
А затем, как правило, произвольное количество позиционных и именованных аргументов, которые передаются в __init__().
Дело в том, что аргументы, указываемые при вызове класса, передаются как в метод __init__(), так и в метод __new__().
Возвращаемое значение метода __new__() - новый экземпляр класса.


class MyClass:							# стандартная сигнатура
    def __new__(cls, *args, **kwargs):
		instance = object.__new__(cls)
        return instance					# object или super() - родитель всех объектов

Т.е, конструкция object.__new__(cls) позволяет нам обратиться к методу __new__() класса object
и создать экземпляр класса cls, в нашем случае класса MyClass.

Метод __new__() является статическим методом. Однако при его определении в классе
не нужно использовать декоратор @staticmethod, так как Python делает это автоматически.

Ручное конструирование экземпляра класса происходит при помощи последовательного вызова методов __new__() и __init__().

-----------------------

Реализация синглтона
При создании пользовательских классов, как правило, не требуется предоставлять собственную реализацию метода __new__().
Однако есть несколько интересных вариантов использования этого метода. Например, мы можем использовать метод __new__()
для создания синглтонов, то есть объектов существующих в единственном экземпляре.

Реализация синглтона возможна с атрибутом класса, содержащим единственный экземпляр класса,
который будет возвращаться при каждом вызове метода __new__()

class Singleton:
    _instance = None

    def __new__(cls, *args, **kwargs):
        if cls._instance is None:                       # при первом вызове создаем объект
            cls._instance = object.__new__(cls)
        return cls._instance

first = Singleton()
second = Singleton()

print(first is second)	# True , т.е. это один и тот же объект