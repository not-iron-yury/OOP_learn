Методы __str__() и __repr__()

Если методы __str__() и __repr__() явно не определены в классе, то используются их базовые реализации.
А базовые реализации возвращают одно и то же значение.
str(car) == car.__str__()		# True
repr(car) == car.__repr__()		# True

Явное опеределение методов позволяет получить удобное строковое представление объектов как в формальном,
так и в неформальном виде. Принято, что метод __repr__() возвращает строку, которую можно преобразовать обратно в объект с помощью eval().

Аналогично функции print(), если объект передается в функцию format() (или f-строку) в качестве самостоятельного аргумента,
то для его отображения автоматически вызывается функция str(). Во всех остальных случаях,
то есть когда объект не передается в качестве самостоятельного аргумента, а, например,
является элементом коллекции, вызывается функция repr().

Методы __str__() и __repr__() всегда должны возвращать объект типа str,
в противном случае будет возбуждено исключение TypeError.

Если в классе реализован метод __repr__(), но не реализован метод __str__(),
то при передаче экземпляра данного класса в функцию str() вызывается реализованный метод __repr__()

class Cat:
    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return f"Cat('{self.name}')"


cat = Cat('Кемаль')

print(str(cat))		# Cat('Кемаль')
print(repr(cat))	# Cat('Кемаль')

Однако если в классе реализован __str__(), но не реализован метод __repr__(),
то при передаче экземпляра данного класса в функцию repr() вызывается базовая реализация метода __repr__().

class Cat:
    def __init__(self, name):
        self.name = name

    def __str__(self):
        return f'Кот по имени {self.name}'


cat = Cat('Кемаль')

print(str(cat))		# Кот по имени Кемаль
print(repr(cat))	# <__main__.Cat object at 0x0000023C38CB6C80>	(базовая реализация)