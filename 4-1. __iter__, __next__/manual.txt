Методы __iter__() и __next__()


У всех итерируемых объектов есть магический метод __iter__(), который преобразует итерируемый объект в итератор.
Встроенная функция iter() вызывает за кулисами именно этот магический метод.

words = ['hello', 'beegeek', 'python']

iterator = iter(words)      # равнозначно words.__iter__()

print(type(words))			# <class 'list'>
print(type(iterator))		# <class 'list_iterator'>

-----------------------

У всех итераторов есть и метод __iter__(), который возвращает сам итератор (сам себя).
Любой итератор является итерируемым объектом, но не наоборот, не любой итерируемый объект является итератором.

words = ['hello', 'beegeek', 'python']
iterator1 = iter(words)                 # равнозначно words.__iter__()
iterator2 = iter(iterator1)             # равнозначно iterator1.__iter__()

print(iterator1 is iterator2)			# True

-----------------------

У всех итераторов есть магический метод __next__(), который обеспечивает выдачу очередного элемента.
Встроенная функция next() вызывает за кулисами именно этот магический метод.

Приведенный ниже код:

words = ['hello', 'beegeek', 'python']

iterator = iter(words)                    # равнозначно words.__iter__()

print(next(iterator))                     # равнозначно iterator.__next__()
print(next(iterator))                     # равнозначно iterator.__next__()

-----------------------

!ВАЖНО. Если объект не является итератором, т.е. у него нет метода __next__(),
то вызов функции next() приведет к возбуждению исключения TypeErrorе.

words = ['hello', 'beegeek', 'python']
print(next(words))			# TypeError: 'list' object is not an iterator


Таким образом, если функции iter() передается итератор, то она возвращает его же. Если же функции iter()
передать итерируемый объект, не являющийся итератором (например, list), то она вернет совсем другой объект – итератор
на основе этого итерируемого объекта.


-----------------------
Примечания

1. Итерируемый объект (iterable) и итератор (iterator) – это протоколы, правила.

2. Особенности итерируемых объектов и итераторов:
	1) любой объект, не вызывающий исключение TypeError при передаче в функцию iter(), — итерируемый объект
	2) любой объект, не вызывающий исключение TypeError при передаче в функцию next(), — итератор
	3) любой объект, возвращающий сам себя при передаче в функцию iter(), — итератор

3. После реализации в классе метода __iter__(), экземпляры данного класса можно преобразовывать
в коллекции с помощью встроенных функций list(), set(), tuple() и str().

4. Встроенная функция iter() преобразует итерируемый объект в итератор.
Именно в таком виде функция используется в большинстве случаев.

iter(iterable) -> iterator

Однако мы можем использовать функцию iter() в еще одном полезном сценарии:

iter(callable, sentinel) -> iterator


Если функции iter() передается два аргумента, то первый аргумент callable должен являться функцией,
а второй аргумент sentinel — некоторым стоп-значением.

В этом случае, созданный итератор будет вызывать указанную функцию callable и проверять
полученное значение на равенство со значением sentinel. Если полученное значение равно sentinel,
то возбуждается исключение StopIteration, иначе итератор выдает значение, полученное из функции callable.

Например, с помощью функции iter() мы можем создать бесконечный итератор, генерирующий единственное значение — 0.

zero_iterator = iter(int, -1)

for i in range(5):
    print(next(zero_iterator)) 	# будет выводить 0 до тех пор, пока не встретится -1, либо пока не исчерпаются итерации

print(type(zero_iterator))		# <class 'callable_iterator'>


Функция int(), которую мы передаем в качестве первого аргумента в функцию iter(), всегда возвращает значение 0,
при этом вторым аргументом (стоп-значением) является -1, которое не будет возвращено никогда.
Таким образом, мы построили 'бесконечный' итератор, генерирующий единственное нулевое значение.
