АРИФМЕТИЧЕСКИЕ ОПЕРАЦИИ

Методы определяют поведение для:
__add__()		сложения (оператор +)
__sub__()	 	вычитания (оператор -)
__mul__()	 	умножения (оператор *)
__truediv__()	обычного деления (оператор /)
__floordiv__()	целочисленного деления (оператор //)
__mod__()		деления по модулю (оператор %)
__pow__()		возведения в степень (оператор **)
__divmod__()	появляется возмоность использовать встроенную функцию divmod()

!ВАЖНО. Результатами арифметических операций являются новые объекты того же класса.


class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                     # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)	# внимание на порядок операндов в скобках


bank1 = PiggyBank(10)
bank2 = bank1 + 5
bank3 = bank1 + 15

print(bank1)	# PiggyBank(10)
print(bank2)	# PiggyBank(15)
print(bank3)	# PiggyBank(25)

print(5 + bank)	# TypeError	из-за неправильного порядка операндов

!ВАЖНО. При выполнении арифметических операций Python автоматически вызывает соответствующий магический метод у первого операнда,
передавая методу в качестве аргумента второй. Это говорит о том, что для корректного выполнения арифметических операций
необходимо располагать операнды в определенном порядке, так как у одного из них реализация выполняемой операции может отсутствовать.

-----------------------

Для реализации арифметических операций, не учитывающих порядок операндов,
в Python доступен дополнительный набор магических методов с префиксом r.
Они отличаются от основных версий тем, что могут применяться к разным операндам.

Методы определяют поведение для:
__radd__()		сложения (оператор +)
__rsub__()		вычитания (оператор -)
__rmul__()		умножения (оператор *)
__rtruediv__()	обычного деления (оператор /)
__rfloordiv__()	целочисленного деления (оператор //)
__rmod__()		деления по модулю (оператор %)



При любой арифметической операции сначала происходит попытка вызвать основную версию магического метода
(без префикса r) у первого операнда, и если он не определен явно или при его вызове была возвращена константа NotImplemented,
происходит попытка вызова отраженной версии магического метода (с префиксом r) у второго операнда.

class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)

    def __radd__(self, other):			# в некоторых случаях можно заменить на __radd__ = __add__
        return self.__add__(other)

	# __radd__ = __add__				# иногда можно испольовать вместо явного метода __radd__

bank = PiggyBank(10)
print(bank + 5)			# PiggyBank(15)
print(5 + bank)			# PiggyBank(15)

num = 5
print(num.__add__(bank))    # NotImplemented , т.к. для int не определен

-----------------------

!ВАЖНО. После реализации в классе операторов сложения появляется возможность
		складывать экземпляры этого класса с помощью встроенной функции sum()

class PiggyBank:
    def __init__(self, coins):
        self.coins = coins

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        if isinstance(other, int):					# сценарий сложения с числом
            return PiggyBank(self.coins + other)
        elif isinstance(other, PiggyBank):			# сценарий сложения с другим объектом этого же класса
            return PiggyBank(self.coins + other.coins)
        return NotImplemented

    def __radd__(self, other):						# сценарий с противоположным порядком операндов
        return self.__add__(other)


banks = [PiggyBank(10), PiggyBank(20), PiggyBank(30)]

print(sum(banks))	# PiggyBank(60)

-----------------------

ОПЕРАТОРЫ СОСТАВНОГО ПРИСВАИВАНИЯ

__iadd__()			+=
__isub__()			-=
__imul__()			*=
__idiv__()			/=
__ifloordiv__()		//=
__imod__()			%=
__ipow__()			**=
__ilshift__()		<<=
__irshift__()		>>=
__iand__()			&=
__ixor__()			^=
__ior__()			|=

!ВАЖНО. Методы, реализующие арифметические операции, должны возвращать свой результат с помощью инструкции return self.

class PiggyBank:
    def __init__(self, coins):
        self.coins = coins                         # количество монет в копилке

    def __repr__(self):
        return f'PiggyBank({self.coins})'

    def __add__(self, other):
        return PiggyBank(self.coins + other)       # создаем и возвращаем новый объект

    def __iadd__(self, other):
        self.coins += other
        return self                                # возвращаем измененный объект


bank = PiggyBank(10)

bank += 10
bank += 5

print(bank)	# PiggyBank(25)


!ВАЖНО. Если в классе не определены магические методы с префиксом i, но определены их основные версии (без префикса i),
то операторами составного присваивания пользоваться можно. Однако результатами таких арифметических операций всегда будут новые объекты.
Это удобно в том случае, когда экземпляры класса являются неизменяемыми.

!ВАЖНО. Для неизменяемых объектов арифметические операции с операторами составного присваивания
равнозначны обычным арифметическим операциям и являются, по сути, лишь краткой записью.

num = 10
id1 = id(num)

num += 5			# переприсвоение (num теперь ссылается на новый int объект)
id2 = id(num)

print(id1 == id2)	# False		 т.к. тип int является неизменяемым и оператор += создает новый объект.

-----------------------

ОПЕРАЦИИ ДВОИЧНОГО СДВИГА И ЛОГИЧЕСКИЕ ОПЕРАЦИИ

Методы определяют поведение для:
__lshift__()	двоичного сдвига влево (оператор <<)
__rshift__()	двоичного сдвига вправо (оператор >>)
__and__()		двоичного И (оператор &)
__or__()		двоичного ИЛИ (оператор |)
__xor__()		двоичного XOR, (оператор ^)

!ВАЖНО. Все приведенные выше методы также имеют отраженные версии (с префиксом r).